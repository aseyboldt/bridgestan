/* automatically generated by rust-bindgen 0.64.0 */

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bs_model_rng {
    _unused: [u8; 0],
}
pub type bool_ = ::std::os::raw::c_int;
extern crate libloading;
pub struct Bridgestan {
    __library: ::libloading::Library,
    pub bs_construct: unsafe extern "C" fn(
        data_file: *mut ::std::os::raw::c_char,
        seed: ::std::os::raw::c_uint,
        chain_id: ::std::os::raw::c_uint,
    ) -> *mut bs_model_rng,
    pub bs_destruct: unsafe extern "C" fn(mr: *mut bs_model_rng) -> ::std::os::raw::c_int,
    pub bs_name: unsafe extern "C" fn(mr: *mut bs_model_rng) -> *const ::std::os::raw::c_char,
    pub bs_model_info: unsafe extern "C" fn(mr: *mut bs_model_rng) -> *const ::std::os::raw::c_char,
    pub bs_param_names: unsafe extern "C" fn(
        mr: *mut bs_model_rng,
        include_tp: bool_,
        include_gq: bool_,
    ) -> *const ::std::os::raw::c_char,
    pub bs_param_unc_names:
        unsafe extern "C" fn(mr: *mut bs_model_rng) -> *const ::std::os::raw::c_char,
    pub bs_param_num: unsafe extern "C" fn(
        mr: *mut bs_model_rng,
        include_tp: bool_,
        include_gq: bool_,
    ) -> ::std::os::raw::c_int,
    pub bs_param_unc_num: unsafe extern "C" fn(mr: *mut bs_model_rng) -> ::std::os::raw::c_int,
    pub bs_param_constrain: unsafe extern "C" fn(
        mr: *mut bs_model_rng,
        include_tp: bool_,
        include_gq: bool_,
        theta_unc: *const f64,
        theta: *mut f64,
    ) -> ::std::os::raw::c_int,
    pub bs_param_unconstrain: unsafe extern "C" fn(
        mr: *mut bs_model_rng,
        theta: *const f64,
        theta_unc: *mut f64,
    ) -> ::std::os::raw::c_int,
    pub bs_param_unconstrain_json: unsafe extern "C" fn(
        mr: *mut bs_model_rng,
        json: *const ::std::os::raw::c_char,
        theta_unc: *mut f64,
    ) -> ::std::os::raw::c_int,
    pub bs_log_density: unsafe extern "C" fn(
        mr: *mut bs_model_rng,
        propto: bool_,
        jacobian: bool_,
        theta: *const f64,
        lp: *mut f64,
    ) -> ::std::os::raw::c_int,
    pub bs_log_density_gradient: unsafe extern "C" fn(
        mr: *mut bs_model_rng,
        propto: bool_,
        jacobian: bool_,
        theta: *const f64,
        val: *mut f64,
        grad: *mut f64,
    ) -> ::std::os::raw::c_int,
    pub bs_log_density_hessian: unsafe extern "C" fn(
        mr: *mut bs_model_rng,
        propto: bool_,
        jacobian: bool_,
        theta: *const f64,
        val: *mut f64,
        grad: *mut f64,
        hessian: *mut f64,
    ) -> ::std::os::raw::c_int,
}
impl Bridgestan {
    pub unsafe fn new<P>(path: P) -> Result<Self, ::libloading::Error>
    where
        P: AsRef<::std::ffi::OsStr>,
    {
        let library = ::libloading::Library::new(path)?;
        Self::from_library(library)
    }
    pub unsafe fn from_library<L>(library: L) -> Result<Self, ::libloading::Error>
    where
        L: Into<::libloading::Library>,
    {
        let __library = library.into();
        let bs_construct = __library.get(b"bs_construct\0").map(|sym| *sym)?;
        let bs_destruct = __library.get(b"bs_destruct\0").map(|sym| *sym)?;
        let bs_name = __library.get(b"bs_name\0").map(|sym| *sym)?;
        let bs_model_info = __library.get(b"bs_model_info\0").map(|sym| *sym)?;
        let bs_param_names = __library.get(b"bs_param_names\0").map(|sym| *sym)?;
        let bs_param_unc_names = __library.get(b"bs_param_unc_names\0").map(|sym| *sym)?;
        let bs_param_num = __library.get(b"bs_param_num\0").map(|sym| *sym)?;
        let bs_param_unc_num = __library.get(b"bs_param_unc_num\0").map(|sym| *sym)?;
        let bs_param_constrain = __library.get(b"bs_param_constrain\0").map(|sym| *sym)?;
        let bs_param_unconstrain = __library.get(b"bs_param_unconstrain\0").map(|sym| *sym)?;
        let bs_param_unconstrain_json = __library
            .get(b"bs_param_unconstrain_json\0")
            .map(|sym| *sym)?;
        let bs_log_density = __library.get(b"bs_log_density\0").map(|sym| *sym)?;
        let bs_log_density_gradient = __library
            .get(b"bs_log_density_gradient\0")
            .map(|sym| *sym)?;
        let bs_log_density_hessian = __library.get(b"bs_log_density_hessian\0").map(|sym| *sym)?;
        Ok(Bridgestan {
            __library,
            bs_construct,
            bs_destruct,
            bs_name,
            bs_model_info,
            bs_param_names,
            bs_param_unc_names,
            bs_param_num,
            bs_param_unc_num,
            bs_param_constrain,
            bs_param_unconstrain,
            bs_param_unconstrain_json,
            bs_log_density,
            bs_log_density_gradient,
            bs_log_density_hessian,
        })
    }
    #[doc = " Construct an instance of a model and pseudorandom number\n generator (PRNG) wrapper.  Data must be encoded in JSON as\n indicated in the *CmdStan Reference Manual*.\n\n @param[in] data_file C-style string. This is either a\n path to JSON-encoded data file (must end with \".json\"), or\n a JSON string literal.\n @param[in] seed seed for PRNG\n @param[in] chain_id identifier for concurrent sequence of PRNG\n draws\n @return pointer to constructed model or `nullptr` if construction\n fails"]
    pub unsafe fn bs_construct(
        &self,
        data_file: *mut ::std::os::raw::c_char,
        seed: ::std::os::raw::c_uint,
        chain_id: ::std::os::raw::c_uint,
    ) -> *mut bs_model_rng {
        (self.bs_construct)(data_file, seed, chain_id)
    }
    #[doc = " Destroy the model and return 0 for success and -1 if there is an\n exception while freeing memory.\n\n @param[in] mr pointer to model and RNG structure\n @return 0 for success and -1 if there is an exception freeing one\n of the model components."]
    pub unsafe fn bs_destruct(&self, mr: *mut bs_model_rng) -> ::std::os::raw::c_int {
        (self.bs_destruct)(mr)
    }
    #[doc = " Return the name of the specified model as a C-style string.\n\n The returned string should not be modified; it is freed when the\n model and RNG wrapper is destroyed.\n\n @param[in] mr pointer to model and RNG structure\n @return name of model"]
    pub unsafe fn bs_name(&self, mr: *mut bs_model_rng) -> *const ::std::os::raw::c_char {
        (self.bs_name)(mr)
    }
    #[doc = " Return information about the compiled model as a C-style string.\n\n The returned string should not be modified; it is freed when the\n model and RNG wrapper is destroyed.\n\n @param[in] mr pointer to model and RNG structure\n @return Information about the model including Stan version, Stan defines, and\n compiler flags."]
    pub unsafe fn bs_model_info(&self, mr: *mut bs_model_rng) -> *const ::std::os::raw::c_char {
        (self.bs_model_info)(mr)
    }
    #[doc = " Return a comma-separated sequence of indexed parameter names,\n including the transformed parameters and/or generated quantities\n as specified.\n\n The parameters are returned in the order they are declared.\n Multivariate parameters are return in column-major (more\n generally last-index major) order.  Parameters are separated with\n periods (`.`).  For example, `a[3]` is written `a.3` and `b[2,\n 3]` as `b.2.3`.  The numbering follows Stan and is indexed from 1.\n\n The returned string should not be modified; it is freed when the\n model and RNG wrapper is destroyed.\n\n @param[in] mr pointer to model and RNG structure\n @param[in] include_tp `true` to include transformed parameters\n @param[in] include_gq `true` to include generated quantities\n @return CSV-separated, indexed, parameter names"]
    pub unsafe fn bs_param_names(
        &self,
        mr: *mut bs_model_rng,
        include_tp: bool_,
        include_gq: bool_,
    ) -> *const ::std::os::raw::c_char {
        (self.bs_param_names)(mr, include_tp, include_gq)
    }
    #[doc = " Return a comma-separated sequence of unconstrained parameters.\n Only parameters are unconstrained, so there are no unconstrained\n transformed parameters or generated quantities.\n\n The parameters are returned in the order they are declared.\n Multivariate parameters are return in column-major (more\n generally last-index major) order.  Parameters are separated with\n periods (`.`).  For example, `a[3]` is written `a.3` and `b[2,\n 3]` as `b.2.3`.  The numbering follows Stan and is indexed from 1.\n\n The returned string should not be modified; it is freed when the\n model and RNG wrapper is destroyed.\n\n @param[in] mr pointer to model and RNG structure\n @return CSV-separated, indexed, unconstrained parameter names"]
    pub unsafe fn bs_param_unc_names(
        &self,
        mr: *mut bs_model_rng,
    ) -> *const ::std::os::raw::c_char {
        (self.bs_param_unc_names)(mr)
    }
    #[doc = " Return the number of scalar parameters, optionally including the\n number of transformed parameters and/or generated quantities.\n For example, a 2 x 3 matrix counts as 6 scalar parameters.\n\n @param[in] mr pointer to model and RNG structure\n @param[in] include_tp `true` to include transformed parameters\n @param[in] include_gq `true` to include generated quantities\n @return number of parameters"]
    pub unsafe fn bs_param_num(
        &self,
        mr: *mut bs_model_rng,
        include_tp: bool_,
        include_gq: bool_,
    ) -> ::std::os::raw::c_int {
        (self.bs_param_num)(mr, include_tp, include_gq)
    }
    #[doc = " Return the number of unconstrained parameters.  The number of\n unconstrained parameters might be smaller than the number of\n parameters if the unconstrained space has fewer dimensions than\n the constrained (e.g., for simplexes or correlation matrices).\n\n @param[in] mr pointer to model and RNG structure\n @return number of unconstrained parameters"]
    pub unsafe fn bs_param_unc_num(&self, mr: *mut bs_model_rng) -> ::std::os::raw::c_int {
        (self.bs_param_unc_num)(mr)
    }
    #[doc = " Set the sequence of constrained parameters based on the specified\n unconstrained parameters, including transformed parameters and/or\n generated quantities as specified, and return a return code of 0\n for success and -1 for failure.  Parameter order is as declared\n in the Stan program, with multivariate parameters given in\n last-index-major order.\n\n @param[in] mr pointer to model and RNG structure\n @param[in] include_tp `true` to include transformed parameters\n @param[in] include_gq `true` to include generated quantities\n @param[in] theta_unc sequence of unconstrained parameters\n @param[out] theta sequence of constrained parameters\n @return code 0 if successful and code -1 if there is an exception\n in the underlying Stan code"]
    pub unsafe fn bs_param_constrain(
        &self,
        mr: *mut bs_model_rng,
        include_tp: bool_,
        include_gq: bool_,
        theta_unc: *const f64,
        theta: *mut f64,
    ) -> ::std::os::raw::c_int {
        (self.bs_param_constrain)(mr, include_tp, include_gq, theta_unc, theta)
    }
    #[doc = " Set the sequence of unconstrained parameters based on the\n specified constrained parameters, and return a return code of 0\n for success and -1 for failure.  Parameter order is as declared\n in the Stan program, with multivariate parameters given in\n last-index-major order.\n\n @param[in] mr pointer to model and RNG structure\n @param[in] theta sequence of constrained parameters\n @param[out] theta_unc sequence of unconstrained parameters\n @return code 0 if successful and code -1 if there is an exception\n in the underlying Stan code"]
    pub unsafe fn bs_param_unconstrain(
        &self,
        mr: *mut bs_model_rng,
        theta: *const f64,
        theta_unc: *mut f64,
    ) -> ::std::os::raw::c_int {
        (self.bs_param_unconstrain)(mr, theta, theta_unc)
    }
    #[doc = " Set the sequence of unconstrained parameters based on the JSON\n specification of the constrained parameters, and return a return\n code of 0 for success and -1 for failure.  Parameter order is as\n declared in the Stan program, with multivariate parameters given\n in last-index-major order. The JSON schema assumed is fully\n defined in the *CmdStan Reference Manual*.\n\n @param[in] mr pointer to model and RNG structure\n @param[in] json JSON-encoded constrained parameters\n @param[out] theta_unc sequence of unconstrained parameters\n @return code 0 if successful and code -1 if there is an exception\n in the underlying Stan code"]
    pub unsafe fn bs_param_unconstrain_json(
        &self,
        mr: *mut bs_model_rng,
        json: *const ::std::os::raw::c_char,
        theta_unc: *mut f64,
    ) -> ::std::os::raw::c_int {
        (self.bs_param_unconstrain_json)(mr, json, theta_unc)
    }
    #[doc = " Set the log density of the specified parameters, dropping\n constants if `propto` is `true` and including the Jacobian terms\n resulting from constraining parameters if `jacobian` is `true`,\n and return a return code of 0 for success and -1 if there is an\n exception executing the Stan program.\n\n @param[in] mr pointer to model and RNG structure\n @param[in] propto `true` to discard constant terms\n @param[in] jacobian `true` to include change-of-variables terms\n @param[in] theta unconstrained parameters\n @param[out] lp log density to be set\n @return code 0 if successful and code -1 if there is an exception\n in the underlying Stan code"]
    pub unsafe fn bs_log_density(
        &self,
        mr: *mut bs_model_rng,
        propto: bool_,
        jacobian: bool_,
        theta: *const f64,
        lp: *mut f64,
    ) -> ::std::os::raw::c_int {
        (self.bs_log_density)(mr, propto, jacobian, theta, lp)
    }
    #[doc = " Set the log density and gradient of the specified parameters,\n dropping constants if `propto` is `true` and including the\n Jacobian terms resulting from constraining parameters if\n `jacobian` is `true`, and return a return code of 0 for success\n and -1 if there is an exception executing the Stan program.  The\n gradient must have enough space to hold the gradient.\n\n The gradients are computed using automatic differentiation.\n\n @param[in] mr pointer to model and RNG structure\n @param[in] propto `true` to discard constant terms\n @param[in] jacobian `true` to include change-of-variables terms\n @param[in] theta unconstrained parameters\n @param[out] val log density to be set\n @param[out] grad gradient to set\n @return code 0 if successful and code -1 if there is an exception\n in the underlying Stan code"]
    pub unsafe fn bs_log_density_gradient(
        &self,
        mr: *mut bs_model_rng,
        propto: bool_,
        jacobian: bool_,
        theta: *const f64,
        val: *mut f64,
        grad: *mut f64,
    ) -> ::std::os::raw::c_int {
        (self.bs_log_density_gradient)(mr, propto, jacobian, theta, val, grad)
    }
    #[doc = " Set the log density, gradient, and Hessian of the specified parameters,\n dropping constants if `propto` is `true` and including the\n Jacobian terms resulting from constraining parameters if\n `jacobian` is `true`, and return a return code of 0 for success\n and -1 if there is an exception executing the Stan program.  The\n pointer `grad` must have enough space to hold the gradient.  The\n pointer `Hessian` must have enough space to hold the Hessian.\n\n The gradients are computed using automatic differentiation.  the\n Hessians are\n\n @param[in] mr pointer to model and RNG structure\n @param[in] propto `true` to discard constant terms\n @param[in] jacobian `true` to include change-of-variables terms\n @param[in] theta unconstrained parameters\n @param[out] val log density to be set\n @param[out] grad gradient to set\n @param[out] hessian hessian to set\n @return code 0 if successful and code -1 if there is an exception\n in the underlying Stan code"]
    pub unsafe fn bs_log_density_hessian(
        &self,
        mr: *mut bs_model_rng,
        propto: bool_,
        jacobian: bool_,
        theta: *const f64,
        val: *mut f64,
        grad: *mut f64,
        hessian: *mut f64,
    ) -> ::std::os::raw::c_int {
        (self.bs_log_density_hessian)(mr, propto, jacobian, theta, val, grad, hessian)
    }
}
